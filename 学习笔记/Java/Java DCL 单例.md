```java
// Broken multithreaded version
// "Double-Checked Locking" idiom
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            synchronized (this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }

    // other functions and members...
}
```
Intuitively, this algorithm seems like an efficient solution to the problem. However, this technique has many subtle problems and should usually be avoided. For example, consider the following sequence of events:

1. Thread _A_ notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
1. Due to the semantics of some programming languages, the code generated by the compiler is allowed to update the shared variable to point to a ==**partially constructed object**== before _A_ has finished performing the initialization. For example, in Java if a call to a constructor has been inlined then the shared variable may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.[[6]](https://en.wikipedia.org/wiki/Double-checked_locking#cite_note-IBM-6)
1. Thread _B_ notices that the shared variable has been initialized (or so it appears), and returns its value. Because thread _B_ believes the value is already initialized, it does not acquire the lock. If _B_ uses the object before all of the initialization done by _A_ is seen by _B_ (either because _A_ has not finished initializing it or because some of the initialized values in the object have not yet percolated to the memory _B_ uses ([cache coherence](https://en.wikipedia.org/wiki/Cache_coherence))), the program will likely crash.

One of the dangers of using double-checked locking in [J2SE 1.4](https://en.wikipedia.org/wiki/Java_Platform,_Standard_Edition) (and earlier versions) is that it will often appear to work: it is not easy to distinguish between a correct [implementation](https://en.wikipedia.org/wiki/Implementation) of the technique and one that has subtle problems. Depending on the [compiler](https://en.wikipedia.org/wiki/Compiler), the interleaving of threads by the [scheduler](https://en.wikipedia.org/wiki/Scheduling_(computing)) and the nature of other [concurrent system activity](https://en.wikipedia.org/wiki/Concurrency_(computer_science)), failures resulting from an incorrect implementation of double-checked locking may only occur intermittently. Reproducing the failures can be difficult.

As of [J2SE 5.0](https://en.wikipedia.org/wiki/Java_Platform,_Standard_Edition), this problem has been fixed. The [volatile](https://en.wikipedia.org/wiki/Volatile_variable) keyword now ensures that multiple threads handle the singleton instance correctly. This new idiom is described in [[3]](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html) and [[4]](http://www.oracle.com/technetwork/articles/javase/bloch-effective-08-qa-140880.html).


```java
// Broken under Java 1.4 and earlier semantics for volatile
class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper localRef = helper;
        if (localRef == null) {
            synchronized (this) {
                localRef = helper;
                if (localRef == null) {
                    helper = localRef = new Helper();
                }
            }
        }
        return localRef;
    }

    // other functions and members...
}
```
Note the local variable "localRef", which seems unnecessary. The effect of this is that in cases where helper is already initialized (i.e., most of the time), the volatile field is only accessed once (due to "return localRef;" instead of "return helper;"), which can improve the method's overall performance by as much as 40 percent.[[7]](https://en.wikipedia.org/wiki/Double-checked_locking#cite_note-7)


---

The (infamous) double-checked locking idiom (also called the multithreaded singleton pattern) is a trick designed to support lazy initialization while avoiding the overhead of synchronization. In very early JVMs, synchronization was slow, and developers were eager to remove it -- perhaps too eager. The double-checked locking idiom looks like this:
```java
// double-checked-locking - don't do this!
private static Something instance = null;
public Something getInstance() {
  if (instance == null) {
    synchronized (this) {
      if (instance == null)
        instance = new Something();
    }
  }
  return instance;
}
```
This looks awfully clever -- the synchronization is avoided on the common code path. There's only one problem with it -- **it doesn't work**. Why not? ==The most obvious reason is that the writes which initialize instance and the write to the instance field can be reordered by the compiler or the cache, which would have the effect of returning what appears to be a partially constructed Something==. The result would be that we read an uninitialized object. There are lots of other reasons why this is wrong, and why algorithmic corrections to it are wrong. There is no way to fix it using the old Java memory model. More in-depth information can be found at [Double-checked locking: Clever, but broken](http://www.javaworld.com/jw-02-2001/jw-0209-double.html) and [The "Double Checked Locking is broken" declaration](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)

Many people assumed that the use of the volatile keyword would eliminate the problems that arise when trying to use the double-checked-locking pattern. In JVMs prior to 1.5, volatile would not ensure that it worked (your mileage may vary). Under the new memory model, making the instance field volatile will "fix" the problems with double-checked locking, because then there will be a happens-before relationship between the initialization of the Something by the constructing thread and the return of its value by the thread that reads it.


Instead, use the Initialization On Demand Holder idiom, which is thread-safe and a lot easier to understand:
```java
private static class LazySomethingHolder {
  public static Something something = new Something();
}
public static Something getInstance() {
  return LazySomethingHolder.something;
}
```
This code is guaranteed to be correct because of the initialization guarantees for static fields; if a field is set in a static initializer, it is guaranteed to be made visible, correctly, to any thread that accesses that class.



**Links**:

1. [https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java](https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java)
1. [http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl)
