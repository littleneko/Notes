# 三色标记法⭐️

## 简介

* **白色对象** — 潜在的垃圾，其内存可能会被垃圾收集器回收；
* **黑色对象** — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
* **灰色对象** — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600017764019-4766820d-7292-46a0-866f-92016bdfba3e.png" alt="image.png" style="zoom: 50%;" />

<center>图 7-25 三色标记垃圾收集器的执行过程</center>

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/2020-03-16-15843705141821-tri-color-mark-sweep-after-mark-phase.png" alt="tri-color-mark-sweep-after-mark-phase" style="zoom:50%;" />

<center>图 7-26 三色标记后的堆</center>

三色标记法仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600017132914-d9ea7e6c-3718-4031-9c8d-d097bd94f3bf.png" alt="image.png" style="zoom:50%;" />

## 屏障技术⭐️

### 三色不变性⭐️

想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种==**三色不变性**==（Tri-color invariant）中的任意一种：

* 强三色不变性 — ==黑色对象不会指向白色对象==，只会指向灰色对象或者黑色对象；
* 弱三色不变性 — ==黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径==；

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600017528544-50982548-0576-45bf-b04b-0b047646b62d.png" alt="image.png" style="zoom:50%;" />



上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。

### Dijkstra 插入写屏障（保证强三色不变性）

```go
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```

每当我们执行类似 `*slot = ptr` 的表达式时，我们会执行上述写屏障通过 shade 函数尝试改变指针的颜色。如果 ptr 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600017984944-c6ed1cd6-f384-4451-946e-da65f82113c8.png" alt="image.png" style="zoom:50%;" />



Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将**有存活可能的对象都标记成灰色**以满足强三色不变性。在如上所示的垃圾收集过程中，==实际上不再存活的 B 对象最后没有被回收==。

假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：

1. 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
2. 用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；
3. 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；

Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将**有存活可能的对象都标记成灰色**以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。

插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。

### Yuasa 删除写屏障（保证弱三色不变性）

```go
writePointer(slot, ptr)
    shade(*slot)
    *slot = ptr
```

上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600018538689-4c51beab-ebdb-40fa-96ea-bbfb1a457cbc.png" alt="image.png" style="zoom:50%;" />

假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：

1. 垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；
2. 用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；
3. **用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色**；
4. 垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；

上述过程中的第三步触发了 Yuasa 删除写屏障的着色，因为用户程序删除了 B 指向 C 对象的指针，所以 C 和 D 两个对象会分别违反强三色不变性和弱三色不变性：

- 强三色不变性 — 黑色的 A 对象直接指向白色的 C 对象；
- 弱三色不变性 — 垃圾收集器无法从某个灰色对象出发，经过几个连续的白色对象访问白色的 C 和 D 两个对象；

Yuasa 删除写屏障通过对 C 对象的着色，保证了 C 对象和下游的 D 对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性。

# 增量和并发

## 增量垃圾收集器

需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，==我们需要在垃圾收集开始前打开写屏障==，这样用户程序对内存的修改都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。



<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600018770440-6b89d62e-f996-45cd-ab1b-391fc5836b47.png" alt="image.png" style="zoom: 67%;" />

## 并发收集器

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600018783470-ecd8faa2-c3f9-4b69-83ba-ac0e825602e2.png" alt="image.png" style="zoom:67%;" />

# Go 的 GC

## 简介

### 并发垃圾收集

首先，并发垃圾收集器必须在合适的时间点触发垃圾收集循环，假设我们的 Go 语言程序运行在一台 4 核的物理机上，那么在垃圾收集开始后，收集器会占用 25% 计算资源在后台来扫描并标记内存中的对象：

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600019340454-1419ac44-3f4e-472e-9909-17d4f7146bdf.png" alt="image.png" style="zoom:67%;" />

### 回收堆目标

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/1600051769200-4dc285e4-0923-4d97-8a95-69e59bf08b5f.png" alt="image.png" style="zoom:67%;" />

### 混合写屏障

在 Go 语言 v1.7 版本之前，运行时会使用 Dijkstra 插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为 Go 语言的应用程序可能包含成百上千的 Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个 Goroutine 的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在实现上选择了==在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描==，在活跃 Goroutine 非常多的程序中，重新扫描的过程需要占用 10 ~ 100ms 的时间。


Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成了如下所示的混合写屏障，==该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色==：

```go
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```

为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要==将创建的所有新对象都标记成黑色==，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。

## 流程

1. 清理终止阶段；
   1. **暂停程序**，所有的处理器在这时会进入安全点（Safe point）；
   1. 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
   1. 将状态切换至 _GCmark、==开启写屏障==、用户程序协助（Mutator Assiste）并将根对象入队；
   1. 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
   1. 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
   1. 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
   1. 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
   1. **暂停程序**、将状态切换至 GCmarktermination 并关闭辅助标记的用户程序；
   1. 清理处理器上的线程缓存；
4. 清理阶段；
   1. 将状态切换至  GCoff 开始清理阶段，初始化清理状态并==关闭写屏障==；
   1. 恢复用户程序，所有新创建的对象会标记成白色；
   1. 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

## GC 时机

- runtime.sysmon 和 runtime.forcegchelper — 后台运行定时检查和垃圾收集；
- runtime.GC — 用户程序手动触发垃圾收集；
- runtime.mallocgc — 申请内存时根据堆大小触发垃圾收集；

# Links

1. https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/
