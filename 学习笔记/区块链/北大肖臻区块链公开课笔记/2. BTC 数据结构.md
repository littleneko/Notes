# 数据结构

## hash 指针

```
+-+----+    +-+----+    +-+----+    +-+----+    +-+----+
|P|    | <- |P|    | <- |P|    | <- |P|    | <- |P|    |
+-+----+    +-+----+    +-+----+    +-+----+    +-+----+
```

hash 值是计算的整个区块，包括指向前一个区块的 hash 指针，改变一个区块，将导致后面所有区块的 hash 都发生变化。因此只需要最后一个区块的 hash 值，就能检测出所有区块是否被修改。

某些节点可以只保存最新的几个区块，需要以前的区块的时候，向其他节点请求，用区块的 hash 值验证其他节点发送过来的区块是否被篡改。

## merkle tree

与普通的 binary tree 的区别是用 hash 指针代替的普通指针，只要记住 root hash，就能检测出对树中任何部位的修改。

比特币中，每个区块所包含的交易，组织成一个 merkle tree。



用途：merkle proof

比特币中全节点保存所有区块内容，轻节点中只保存 block header，如何向一个轻节点证明一个交易已经被写到区块链中了？

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221016134336219.png" alt="image-20221016134336219" style="zoom: 25%;" />

比如：一个轻节点想知道图中标成黄色的交易是否包含到区块链中了，轻节点只有根 hash 值？

轻节点向全节点请求 merkle proof，全节点把图中标成红色的 hash 值发给轻节点，有了这个信息后，轻节点可以在本地计算图中标成绿色的 hash 值，轻节点把最后算出的根节点的 hash 值和 block header 中的 hash 值进行比较，就能知道黄色的 tx 是否包含在区块中。

复杂度：O(log(n))



是否能验证某一个交易不在区块中？（proof of non-membership）：需要先排序。

