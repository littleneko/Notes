2. BTC-实现

区块链是一个去中心化的账本，BTC 使用的是基于交易的模式（transaction-based ledger），每个区块里记录的是交易信息，包括转账交易和铸币交易，但是系统里并没有显示地记录每个账户上有多少钱，需要通过交易记录来推算。

全节点需要维护一个 UTXO(Unspent Transaction Oupput)，一个交易有多个输出，UTXO 需要记录交易的 hash 值以及在 output 中的位置，UTXO 的目的是为了快速检测 double spending。

==========================

交易费（transaction fee）
为了激励矿工，一个交易的 input - output 作为交易费给矿工

现阶段矿工主要还是为了挣出块奖励，交易费占很小一部分，但是出块奖励每 21 万个区块（大约 4 年）减半。

以太坊使用基于账户的模式（account-based ledger），比较符合生活常识

===========================

nonce 一共 4 字节，就算把 2^32 就算全部遍历完可能也找不到符合 target 的值，block header 中还有哪些域就可以调整？

block header:
* version
* hash of previous block header
* hash of merkle root
* time: 可以适当调整
* nbits: 即 target
* nonce

改 merkle root 的 hash 值，铸币交易有一个 coinbase 域，可以写任意内容，改变这个域的内容就会引起 铸币交易 的 hash 值发生变化，最终传递到 root

====================
挖矿

挖矿就是不断的尝试 nonce，每次尝试可以看成是一个 Bernoulli Trial (a random experiment with binary outcome)

很多个 Bernoulli Trial 构成 Bernoulli Process (a sequence of independent Bernoulli Trials)，其一个重要性质是 “无记忆性(memoryless)”，即前面的结果对后面的结果没有影响。

可以用 Poisson Process 来近似

出块时间服从指数分布


图（TODO）

整个系统的平均出块时间 10 分钟

每一个矿工平均挖到下一个区块的时间取决于算里占系统总算力的百分比，比如 A 占总算力的 1%，那么平均下来系统里每产生 100 个区块，有一个区块是 A 挖到的。

指数分布也是无记忆的，概率密度曲线从任何一个地方截断，与原来的形状一样，仍然服从指数分布。

比如现在过去 10 分钟了，仍然没有人找到合法的区块，接下来平均还要等 10 分钟才能出块，即将来还要挖多长时间和已经挖了多长时间没有关系。这个性质也叫 progress free。


如果不满足这个性质会有什么情况，比如过去做的工作越多，接下来尝试 nonce 成功的概率会更大：算力强的矿工会有不成比例的优势，因为算力强的矿工过去做的工作多。比如系统中有两个矿工，一个算力是另一个的 10 倍，那么理想状况下，算力强的矿工挖到矿的概率是另一个的 10 倍；但是如果不满足 progress free，算力强的矿工挖到矿的概率会大于 10 倍，因为他过去尝试过更多的 nonce。

=====================================

比特币总量：

21万 * 50 + 21万 * 25 + 21万 * 12.5 + ... ...
= 21万 * 50 * (1 + 1/2 + 1/4 + ... ...)
= 2100 万

挖矿本身的计算没有意义，但是挖矿对于维护比特币系统本身的安全性至关重要，挖矿提供了一种凭算力投票的权利，只要系统中大多数节点是诚实的节点。

==================================


比特币的安全性

假设大多数算力掌握在诚实的矿工手里

1. 是否能偷币
不行，因为无法伪造别人的签名，如果他把交易发布到链上，其他节点不会接受这个区块，会从上一个节点继续挖，对于作弊的节点来说浪费了算力还没得到任何好处。

2. 是否能把花过的币再花一遍

口 <- 口 <- 口 <- 口(M->A)
            ^--- 口(M-M')

这两个链都是合法的，取决于其他节点沿着哪条链挖。

比如 M 在 A 这里买了某个商品，A 发现交易已经写到链里了，把商品给了 M，然后 M 又发起一个 M->M' 的交易，然后把下面的链延伸成最长合法连。

怎么防范这种攻击？
等到更多的区块被确认（一般来说 6 个就够了）后再把商品发给 M，然后 M 再发布 M->M' 区块的时候，这个链很难扩展成最长合法链，因为其他节点都会沿着上面的最长合法链来挖。

3. 故意不把某些交易写到区块里。没问题，下一个区块大概率是诚实的区块，会把这个交易写进去

4. selfish ming
挖出区块来先不发布，自己继续挖，等到后面一次性发布。

一旦发布，其他节点也会放弃当前挖的区块，然后沿着这个区块向下挖，但是如果不发布，其他节点还是在沿着老的区块挖，自己可以先挖下一个区块，挖出去之后继续挖。

风险，可能自己还没挖出下下一个区块的时候，其他人已经挖出了下一个区块，这时候需要马上把这个区块发布出去。