# 交易树和收据树

每次发布一个区块时，区块中的交易会形成一颗 Merkle Tree，即==交易树==。此外，以太坊还添加了一个==收据树==，每个交易执行完之后形成一个收据，记录交易相关信息。也就是说，交易树和收据树上的节点是一一对应的。

由于以太坊智能合约执行较为复杂，通过增加收据树，便于快速查询执行结果。

交易树和收据树都是 M(Merkle)PT，而 BTC 中都采用普通的 MT(Merkle Tree)。

==MPT 的好处是支持查找操作，通过键值沿着树进行查找即可==。==对于状态树，查找键值为账户地址==；==对于交易树和收据树，查找键值为交易在发布的区块中的序号==。

交易树和收据树只将当前区块中的交易组织起来，而状态树将所有账户的状态都包含进去，无论这些账户是否与当前区块中交易有关系。多个区块状态树共享节点，而交易树和收据树依照区块独立。

**交易树和收据树的用途**：

* 向轻节点提供 Merkle Proof。
* 更加复杂的查找操作（例如：查找过去十天的交易；过去十天的众筹事件等）



# Bloom filter（布隆过滤器）

支持较为高效查找某个元素是否在某个集合中。

* Bloom filter 特点：有可能出现误报，但不会出现漏报。
* Bloom filter 变种：采用一组哈希函数进行向量映射，有效避免哈希碰撞

简单的 Bloom filter 不支持删除操作。如果想要支持删除操作，需要将记录数不能为 0 和 1，需要修改为一个计数器（需要考虑计数器是否会溢出）。

## 以太坊中 Bloom filter 的作用
每个交易完成后会产生一个收据，收据包含一个 Bloom filter 记录==交易类型==、==地址==等信息。在区块 block header 中也包含一个 Bloom filter，其为该区块中所有交易的 Bloom filter 的一个并集。

所以，查找时候先查找块头中的 Bloom filter，如果块头中包含。再查看区块中包含的交易的 Bloom filter，如果存在，再查看交易进行确认；如果不存在，则说明发生了“碰撞”。

好处是通过 Bloom filter 这样一个结构，快速大量过滤掉大量无关区块，从而提高了查找效率。



>  **Q&A**
>
> **Q1**：A 转账到 B，有没有可能收款账户不包含再状态树中？
>
> **A1**：可能。因为以太坊中账户可以节点自己产生，只有在产生交易时才会被系统知道。
>
> **Q2**：可否将每个区块中状态树更改为只包含和区块中交易相关的账户状态？(大幅削减状态树大小，且和交易树、收据树保持一致)
>
> **A2**：不能。首先，这样设计要查找账户状态很不方便，因为不存在某个区块包含所有状态。其次，==如果要向一个新创建账户转账，因为需要知道收款账户的状态，才能给其添加金额，但由于其是新创建的账户，所有需要一直找到创世纪块才能知道该账户为新建账户的==。



# 代码中的数据结构

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221028000416867.png" alt="image-20221028000416867" style="zoom:50%;" />

![image-20221028000435439](https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221028000435439.png)

![image-20221028000507393](https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221028000507393.png)
