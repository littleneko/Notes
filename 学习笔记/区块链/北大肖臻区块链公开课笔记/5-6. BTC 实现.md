# 基于交易的模式

区块链是一个去中心化的账本，BTC 使用的是**基于交易的模式**（transaction-based ledger），每个区块里记录的是交易信息，包括转账交易和铸币交易，但是系统里并没有显示地记录每个账户上有多少钱，需要通过交易记录来推算。

全节点需要在内存中维护一个未花费交易输出（==UTXO== ，Unspent Transaction Oupput），一个交易可能有多个输出，UTXO 需要记录交易的 hash 值以及在 output 中的位置，就可以定位到这个输出，UTXO 的目的是为了快速检测 double spending。



==交易费（transaction fee）==：为了激励矿工，一个交易的 input - output 作为交易费给矿工。

现阶段矿工主要还是为了挣出块奖励，交易费占很小一部分，但是出块奖励每 21 万个区块（大约 4 年）减半。

以太坊使用**基于账户的模式**（account-based ledger），系统需要显示地记录每个账户上有多少币，这种方式比较符合生活常识。基于交易的模式中，每笔交易需要说明币的来源，因为系统中没有账户的概念。



下面是一个实际的 block 的例子（https://www.blockchain.com/explorer/blocks/btc/529709）

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221016233545691.png" alt="image-20221016233545691" style="zoom:50%;" />

下面是这个 block 中一个 tracsaction 的例子（https://www.blockchain.com/btc/tx/3fd0d94dcf733a614f14a930a470241e0d99ea6966f999f1fa6f895396a6645f）

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221016233753833.png" alt="image-20221016233753833" style="zoom:50%;" />

# 挖矿

挖矿就是找出符合 hash(header) <= target 的 nonce 值（即符合 block header hash 的前 N 位是 0 的值）。

不过 nonce 一共 4 字节，随着挖矿难度越来越大，就算把 2^32 就算全部遍历完可能也找不到符合 target 的值，block header 中还有哪些域就可以调整？

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221016232647485.png" alt="image-20221016232647485" style="zoom: 50%;" />

https://developer.bitcoin.org/reference/block_chain.html



答案是 merkle root 的 hash 值，铸币交易有一个 coinbase 域，可以写任意内容，改变这个域的内容就会引起**铸币交易**的 hash 值发生变化，最终传递到 root。

<img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221016233301998.png" alt="image-20221016233301998" style="zoom:25%;" />

## 挖矿概率分析

挖矿就是不断的尝试 nonce，每次尝试可以看成是一个 Bernoulli Trial (a random experiment with binary outcome)，很多个 Bernoulli Trial 构成 Bernoulli Process (a sequence of independent Bernoulli Trials)，其一个重要性质是 “==无记忆性 (memoryless)==”，即前面的结果对后面的结果没有影响。

在比特币挖矿中，实验次数很多，每次成功的概率很小，可以用 Poisson Process 来近似，出块时间服从指数分布。



BTC 中整个系统的平均出块时间 10 分钟，通过调整挖矿难度来实现。每一个矿工平均挖到下一个区块的时间取决于算力占系统总算力的百分比，比如 A 占总算力的 1%，那么平均下来系统里每产生 100 个区块，有一个区块是 A 挖到的，即平均等待 1000 分钟产生一个区块。



指数分布也是==无记忆==的，概率密度曲线从任何一个地方截断，与原来的形状一样，仍然服从指数分布。

==比如现在过去 10 分钟了，仍然没有人找到合法的区块，接下来平均还要等 10 分钟才能出块，即将来还要挖多长时间和已经挖了多长时间没有关系，这个性质也叫 progress free==。


如果不满足这个性质会有什么情况，比如过去做的工作越多，接下来尝试 nonce 成功的概率会更大：算力强的矿工会有不成比例的优势，因为算力强的矿工过去做的工作多。比如系统中有两个矿工，一个算力是另一个的 10 倍，那么理想状况下，算力强的矿工挖到矿的概率是另一个的 10 倍；但是如果不满足 progress free，算力强的矿工挖到矿的概率会大于 10 倍，因为他过去尝试过更多的 nonce。

# 比特币总量

挖矿奖励是系统中产生新比特币的唯一方法：

21万 * 50 + 21万 * 25 + 21万 * 12.5 + ... ...
= 21万 * 50 * (1 + 1/2 + 1/4 + ... ...)
= 2100 万

# 比特币的安全性

==挖矿本身的计算没有意义，但是挖矿对于维护比特币系统本身的安全性至关重要，挖矿提供了一种凭算力投票的权利，只要系统中大多数节点是诚实的节点，系统的安全性就能得到保证。==

假设大多数算力掌握在诚实的矿工手里：

* 是否能偷币？

  不行，因为无法伪造别人的签名，如果他把交易发布到链上，其他节点不会接受这个区块，会从上一个节点继续挖，对于作弊的节点来说浪费了算力还没得到任何好处。

* 是否能把花过的币再花一遍？(即分叉攻击)

  <img src="https://littleneko.oss-cn-beijing.aliyuncs.com/img/image-20221017000354921.png" alt="image-20221017000354921" style="zoom:25%;" />

  这两个链都是合法的，取决于其他节点沿着哪条链挖。比如 M 在 A 这里买了某个商品，A 发现交易已经写到链里了，把商品给了 M，然后 M 又发起一个 M->M' 的交易，然后把下面的链延伸成最长合法连。

  防范这种攻击：==等到更多的区块被确认（一般来说 6 个就够了）==后再把商品发给 M，然后 M 再发布 M->M' 区块的时候，这个链很难扩展成最长合法链，因为其他节点都会沿着上面的最长合法链来挖。另外比特币默认是接收第一个收到的区块，等到收到货了再发布另一个区块，这个区块大概率不会被接受。

* 故意不把某些交易写到区块里：没问题，下一个区块大概率是诚实的区块，会把这个交易写进去。

* selfish ming：挖出区块来先不发布，自己继续挖，等到后面一次性发布。

  一旦发布，其他节点也会放弃当前挖的区块，然后沿着这个区块向下挖，但是如果不发布，其他节点还是在沿着老的区块挖，自己可以先挖下一个区块，挖出去之后继续挖。

  风险，可能自己还没挖出下下一个区块的时候，其他人已经挖出了下一个区块，这时候需要马上把这个区块发布出去。

# 比特币网络

比特币网络分为两层：

1. Application Layer: Bitcoin Block Chan
2. Network Layer: P2P Overlay Network

比特币中所有节点都是对等的，一个新节点想要加入比特币网络，需要知道至少一个种子节点。

比特币网络的设计原则是简单、鲁棒，而不是高效。

每个节点维护一个邻居节点的集合，消息传播在网络中采取 flooding 的方式，邻居节点的选择是随机的，和节点的具体位置无关。



每个节点需要维护一个等待上链的交易的集合，第一次收到某个交易的时候，把这个交易加入集合，验证合法后转发给邻居节点。

如果有两个有冲突的交易，不同节点收到两个交易的顺序可能不同，依据先收到哪个交易就接受哪个交易的原则处理。
